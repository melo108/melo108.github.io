---
layout: post
title:  "Django的MTV模型详解之(1)视图"
description:  views
date:   2017-05-23 14:25:52 +0200
categories: jekyll update
---




# Django的MTV模型详解之(1)视图
------

<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516714973018&di=13b6bfc37ce9f8804c542127c7122dfd&imgtype=0&src=http%3A%2F%2Fassets.tianmaying.com%2Fmd-image%2F0a7650b34227a541ffdf4c20e5c1c52a.png">

<br>

## 1 视图层 views

<br>

**(1) 路由配置--URL配置(URLconf)**

URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是**URL与要为该URL调用的视图函数之间的映射表**；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。


	
	
	urlpatterns = [
	     url(正则表达式, views视图函数，参数，别名),
	]
	
	
	参数说明：
	
	一个正则表达式字符串
	一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串
	可选的要传递给视图函数的默认参数（字典形式）
	一个可选的name参数
	




<br>

- **URLconf的正则字符串参数**


> **简单配置,无名分组()**

	from django.conf.urls import url
	
	from . import views
	
	urlpatterns = [
	    url(r'^articles/2003/$', views.special_case_2003),
	    url(r'^articles/([0-9]{4})/$', views.year_archive),
	    url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),
	    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail)


	 NOTE:
	1 一旦匹配成功则不再继续
	2 若要从URL 中捕获一个值，只需要在它周围放置一对圆括号。
	3 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。
	4 每个正则表达式前面的'r' 是可选的但是建议加上。


> **有名分组(named group)**


可以使用命名的正则表达式组来捕获URL 中的值并以关键字 参数传递给视图。

在Python 正则表达式中，命名正则表达式组的语法是(?P<name>pattern)，其中name 是组的名称，pattern 是要匹配的模式。

	from django.conf.urls import url
	
	from . import views
	
	urlpatterns = [
	    url(r'^articles/2003/$', views.special_case_2003),
	    url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
	    url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
	    url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<day>[0-9]{2})/$', views.article_detail),
	]

    /articles/2005/03/    
    请求将调用views.month_archive(request, year='2005', month='03')函数
    /articles/2003/03/03/ 
    请求将调用函数views.article_detail(request, year='2003', month='03', day='03')。

<br>

- **URLconf 路由的查找方式**

URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串**。不包括GET和POST参数以及域名**。

	例如，http://www.example.com/myapp/ 请求中，URLconf 将查找myapp/。

	在http://www.example.com/myapp/?page=3 请求中，URLconf 仍将查找myapp/。

URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的POST、GET、HEAD等等 —— 都将路由到相同的函数。



>  **注意：捕获的参数永远是字符串**


	每个捕获的参数都作为一个普通的Python 字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中：
	
	url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
	views.year_archive() 的year 参数将是一个字符串


<br>

- **URLconf 路由分发（Including other URLconfs）**

将路由细分到某个app中的urls.py中，需要在该app中新建

	
		from django.conf.urls import include, url
		
		urlpatterns = [
		   url(r'^admin/', admin.site.urls),
		   url(r'^blog/', include('blog.urls')),
		]


<br>

- **传递额外的选项给视图函数(了解)**


django.conf.urls.url() 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。

	from django.conf.urls import url
	from . import views
	
	urlpatterns = [
	    url(r'^blog/(?P<year>[0-9]{4})/$', views.year_archive, {'foo': 'bar'}),
	]

	在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year='2005', foo='bar')。

	这个技术在Syndication 框架中使用，来传递元数据和选项给视图。

<br>

- **URL 的反向解析**

反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。即根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。

在需要URL 的地方，**对于不同层级，Django 提供不同的工具用于URL 反查**：
	
	在模板中：使用url 模板标签。

	在Python 代码中：使用django.core.urlresolvers.reverse() 函数。

	在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。

<br>

**URLconf：**

	from django.conf.urls import url
	
	from . import views
	
	urlpatterns = [
	
	    url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'),
	    
	]

**模板**

	<a href="{% url 'news-year-archive' 2012 %}">2012 Archive</a>
	
	<ul>
	{% for yearvar in year_list %}
	<li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>
	{% endfor %}
	</ul>

**views Python 代码**

	from django.core.urlresolvers import reverse
	from django.http import HttpResponseRedirect
	
	def redirect_to_year(request):

	    year = 2006

	    return HttpResponseRedirect(reverse('news-year-archive', args=(year,)))





<br>

**(2) 视图函数**

一个视图函数，简称视图，是一个简单的Python 函数，它接受Web请求并且返回Web响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片. . . 是任何东西都可以。

无论视图本身包含什么逻辑，都要返回响应。每个视图函数都负责返回一个HttpResponse对象。

代码写在哪里也无所谓，只要它在你的Python目录下面。除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，约定是将视图放置在项目或应用程序目录中的名为views.py的文件中。


> **HttpRequest对象的属性**

	
	
	1.HttpRequest.body
	
	　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。
	
	　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。
	
	　　另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。
	
	 
	
	2.HttpRequest.path
	
	　　一个字符串，表示请求的路径组件（不含域名）。
	
	　　例如："/music/bands/the_beatles/"
	
	
	
	3.HttpRequest.method
	
	　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。
	
	　　例如："GET"、"POST"
	
	 
	
	4.HttpRequest.encoding
	
	　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。
	   这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。
	   接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。
	   如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。
	
	 
	
	5.HttpRequest.GET 
	
	　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。
	
	 
	
	6.HttpRequest.POST
	
	　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。
	
	　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。
	   因此，不应该使用 if request.POST  来检查使用的是否是POST 方法；应该使用 if request.method == "POST" 
	
	　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。
	
	 
	
	7.HttpRequest.REQUEST
	
	　　一个类似于字典的对象，它首先搜索POST，然后搜索GET，主要是为了方便。灵感来自于PHP 的 $_REQUEST。
	
	　　例如，如果 GET = {"name": "john"}  而 POST = {"age": '34'} ， REQUEST["name"]  将等于"john"， REQUEST["age"]  将等于"34"。
	
	　　强烈建议使用 GET 和 POST 而不要用REQUEST，因为它们更加明确。
	
	 
	
	8.HttpRequest.COOKIES
	
	　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。
	
	 
	
	9.HttpRequest.FILES
	
	　　一个类似于字典的对象，包含所有的上传文件信息。
	   FILES 中的每个键为<input type="file" name="" /> 中的name，值则为对应的数据。
	
	　　注意，FILES 只有在请求的方法为POST 且提交的<form> 带有enctype="multipart/form-data" 的情况下才会
	   包含数据。否则，FILES 将为一个空的类似于字典的对象。
	
	 
	
	10.HttpRequest.META
	
	 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例：
	
	    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。
	    CONTENT_TYPE —— 请求的正文的MIME 类型。
	    HTTP_ACCEPT —— 响应可接收的Content-Type。
	    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。
	    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。
	    HTTP_HOST —— 客服端发送的HTTP Host 头部。
	    HTTP_REFERER —— Referring 页面。
	    HTTP_USER_AGENT —— 客户端的user-agent 字符串。
	    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。
	    REMOTE_ADDR —— 客户端的IP 地址。
	    REMOTE_HOST —— 客户端的主机名。
	    REMOTE_USER —— 服务器认证后的用户。
	    REQUEST_METHOD —— 一个字符串，例如"GET" 或"POST"。
	    SERVER_NAME —— 服务器的主机名。
	    SERVER_PORT —— 服务器的端口（是一个字符串）。
	 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时，
	    都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_  前缀。
	    所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。
	
	 
	11.HttpRequest.user
	
	　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。
	
	　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。
	
	    例如：
	
	    if request.user.is_authenticated():
	        # Do something for logged-in users.
	    else:
	        # Do something for anonymous users.
	     
	
	     　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。
	
	     
	
	    匿名用户
	    class models.AnonymousUser
	
	    django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点：
	
	    id 永远为None。
	    username 永远为空字符串。
	    get_username() 永远返回空字符串。
	    is_staff 和 is_superuser 永远为False。
	    is_active 永远为 False。
	    groups 和 user_permissions 永远为空。
	    is_anonymous() 返回True 而不是False。
	    is_authenticated() 返回False 而不是True。
	    set_password()、check_password()、save() 和delete() 引发 NotImplementedError。
	    New in Django 1.8:
	    新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。
	
	 
	
	12.HttpRequest.session
	
	 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。
	    完整的细节参见会话的文档。
	
	 
	13.HttpRequest.resolver_match
	
	　　一个 ResolverMatch 的实例，表示解析后的URL。这个属性只有在 URL 解析方法之后才设置，这意味着它在所有的视图中可以访问，
	   但是在 URL 解析发生之前执行的中间件方法中不可以访问（比如process_request，但你可以使用 process_view 代替）。

> **HttpRequest对象的方法**

	
	1.HttpRequest.get_host()
	
	　　根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。
	   如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。
	
	　　USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。
	
	　　例如："127.0.0.1:8000"
	
	　　注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。
	
	 
	
	2.HttpRequest.get_full_path()
	
	　　返回 path，如果可以将加上查询字符串。
	
	　　例如："/music/bands/the_beatles/?print=true"
	
	 
	
	3.HttpRequest.build_absolute_uri(location)
	
	　　返回location 的绝对URI。如果location 没有提供，则使用request.get_full_path()的返回值。
	
	　　如果URI 已经是一个绝对的URI，将不会修改。否则，使用请求中的服务器相关的变量构建绝对URI。
	
	　　例如："http://example.com/music/bands/the_beatles/?print=true"
	
	 
	
	4.HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)
	
	　　返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。
	
	　　如果提供 default 参数，将不会引发异常并返回 default 的值。
	
	　　可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。
	
	        复制代码
	        >>> request.get_signed_cookie('name')
	        'Tony'
	        >>> request.get_signed_cookie('name', salt='name-salt')
	        'Tony' # 假设在设置cookie的时候使用的是相同的salt
	        >>> request.get_signed_cookie('non-existing-cookie')
	        ...
	        KeyError: 'non-existing-cookie'    # 没有相应的键时触发异常
	        >>> request.get_signed_cookie('non-existing-cookie', False)
	        False
	        >>> request.get_signed_cookie('cookie-that-was-tampered-with')
	        ...
	        BadSignature: ...    
	        >>> request.get_signed_cookie('name', max_age=60)
	        ...
	        SignatureExpired: Signature age 1677.3839159 > 60 seconds
	        >>> request.get_signed_cookie('name', False, max_age=60)
	        False
	        复制代码
	         
	
	 
	
	5.HttpRequest.is_secure()
	
	　　如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。
	
	 
	
	6.HttpRequest.is_ajax()
	
	　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。
	
	　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。
	
	　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 
	   你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。
	
	
	
	7.HttpRequest.read(size=None)
	
	　　像文件一样读取请求报文的内容主体，同样的，还有以下方法可用。
	
	　　HttpRequest.readline()
	
	　　HttpRequest.readlines()
	
	　　HttpRequest.xreadlines()
	
	　　其行为和文件操作中的一样。
	
	　　HttpRequest.__iter__()：说明可以使用 for 的方式迭代文件的每一行。'''


**注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：**

	request.POST.getlist("hobby")

<br>


> **render 函数**

	render(request, template_name[, context]）

结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。
	
	参数：
	     request： 用于生成响应的请求对象。
	
	     template_name：要使用的模板的完整名称，可选的参数
	
	     context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。
	
	     content_type：生成的文档要使用的MIME类型。默认为DEFAULT_CONTENT_TYPE 设置的值。
	
	     status：响应的状态码。默认为200。


> **redirect 函数**

	参数可以是：
	
	一个模型：将调用模型的get_absolute_url() 函数

	一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称
	一个绝对的或相对的URL，将原封不动的作为重定向的位置。

	默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。


**你可以用多种方式使用redirect() 函数。**


> 传递一个对象

将调用get_absolute_url() 方法来获取重定向的URL：

	from django.shortcuts import redirect
	 
	def my_view(request):
	    ...
	    object = MyModel.objects.get(...)
	    return redirect(object)

> 传递一个视图的名称

可以带有位置参数和关键字参数；将使用reverse() 方法反向解析URL：　

	def my_view(request):
	    ...
	    return redirect('some-view-name', foo='bar')

> 传递要重定向的一个硬编码的URL

	
	def my_view(request):
	    ...
	    return redirect('/some/url/')

> 也可以是一个完整的URL：

	def my_view(request):
	    ...
	    return redirect('http://example.com/')

默认情况下，redirect() 返回一个临时重定向。以上所有的形式都接收一个permanent 参数；如果设置为True，将返回一个永久的重定向：
	
	def my_view(request):
	    ...
	    object = MyModel.objects.get(...)
	    return redirect(object, permanent=True)　　

**redirect关键点：两次请求过程，掌握流程。**

<br>

> **注意：render和redirect的区别:**

1、 if 页面需要模板语言渲染,需要的将数据库的数据加载到html,那么render方法则不会显示这一部分。

2、 the most important: url没有跳转到/yuan_back/,而是还在/login/,所以当刷新后又得重新登录。



<br>
